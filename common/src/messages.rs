use serde::{Deserialize, Serialize};

/// User data generated by the producer and consumed by students.
/// Sent to the `new_users` topic.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct User {
    pub email: String,
    pub credit_card_number: String,
    pub company_name: String,
    pub company_slogan: String,
    pub industry: String,
    pub user_name: String,
    pub avatar: String,
    pub name: String,
    pub profession: String,
    pub field: String,
    pub premium: bool,
    pub credit: i32,
    pub time_zone: String,
    pub user_agent: String,
    pub pack: String,
}

#[cfg(feature = "fake-data")]
impl User {
    /// Generate a new random user using the fake crate
    pub fn random() -> Self {
        use fake::faker::{address, company, creditcard, internet, job, name};
        use fake::Fake;

        Self {
            email: internet::en::FreeEmail().fake(),
            user_name: internet::en::Username().fake(),
            user_agent: internet::en::UserAgent().fake(),
            avatar: if fake::faker::boolean::en::Boolean(90).fake() {
                format!(
                    "https://robohash.org/{}.png?size=50x50",
                    internet::en::Username().fake::<String>()
                )
            } else {
                String::from("example.org")
            },
            field: job::en::Field().fake(),
            company_name: company::en::CompanyName().fake(),
            company_slogan: company::en::CatchPhrase().fake(),
            profession: company::en::Profession().fake(),
            industry: company::en::Industry().fake(),
            premium: fake::faker::boolean::en::Boolean(50).fake(),
            credit: (-20..20).fake::<i32>(),
            time_zone: address::en::TimeZone().fake(),
            name: if fake::faker::boolean::en::Boolean(90).fake() {
                name::en::Name().fake::<String>()
            } else {
                String::from("John Doe")
            },
            credit_card_number: creditcard::en::CreditCardNumber().fake(),
            pack: if fake::faker::boolean::en::Boolean(10).fake() {
                String::from("free")
            } else {
                String::from("small")
            },
        }
    }
}

/// Action message produced by students to the `actions` topic.
/// Contains filtered/transformed user data.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Action {
    pub customer: Option<String>,
    #[serde(rename = "type")]
    pub action_type: Option<String>,
    pub reason: Option<String>,
    pub team: String,
}

impl Action {
    /// Create a new action with all required fields
    pub fn new(customer: &str, action_type: &str, reason: &str, team: &str) -> Self {
        Self {
            customer: Some(customer.to_string()),
            action_type: Some(action_type.to_string()),
            reason: Some(reason.to_string()),
            team: team.to_string(),
        }
    }
}

/// Watchlist entry produced by students to the `watchlist` topic.
/// Contains flagged premium users grouped by company.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WatchlistEntry {
    pub team: String,
    pub company: String,
    pub flag_count: u32,
}

impl WatchlistEntry {
    pub fn new(team: &str, company: &str, flag_count: u32) -> Self {
        Self {
            team: team.to_string(),
            company: company.to_string(),
            flag_count,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_action_serialization() {
        let action = Action::new("alice@example.com", "CONTACT", "VIP", "team-1");
        let json = serde_json::to_string(&action).unwrap();
        assert!(json.contains("\"customer\":\"alice@example.com\""));
        assert!(json.contains("\"type\":\"CONTACT\""));
    }

    #[test]
    fn test_watchlist_serialization() {
        let entry = WatchlistEntry::new("team-2", "Acme Corp", 5);
        let json = serde_json::to_string(&entry).unwrap();
        assert!(json.contains("\"company\":\"Acme Corp\""));
    }

    #[cfg(feature = "fake-data")]
    #[test]
    fn test_random_user() {
        let user = User::random();
        assert!(!user.email.is_empty());
        assert!(!user.company_name.is_empty());
    }
}
